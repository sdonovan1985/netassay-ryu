#########################
# NetAssay Project
#########################

# Copyright 2015 - Sean Donovan
# Copyright 2014 - Sean Donovan

# DNS Metadata Engine
# Updated for the netassay-ryu project.

ACTIVE_MAPPING = True

import logging
from base.singleton import Singleton

from dnsclassifier.dnsclassify import *
from dnsentry import DNSClassifierEntry as DNSEntry
from base.me.metadataengine import *
from base.RegisteredMatchActions import *

if ACTIVE_MAPPING == True:
    from dns import resolver, exception
    from base.lib.py_timer import py_timer as Timer


class DNSMetadataEngineException(Exception):
    pass

class DNSMetadataEngine(MetadataEngine):
    __metaclass__ = Singleton
    def __init__(self):
        super(DNSMetadataEngine, self).__init__(DNSClassifier(), 
                                                DNSMetadataEntry)

        # Register the different actions this ME can handle
        RegisteredMatchActions().register('domain', self)
        #RegisteredMatchActions.register('class', matchClass)

    def __del__(self):
        # Clean up timer, lest we cause other problems...
        self.logger.debug("__del__ called.")
        if ACTIVE_MAPPING == True:
            if self._active_timer is not None:
                self._active_timer.cancel()
                self._active_timer.join()

    def get_forwarding_rules(self):
        """
        This gets the forwarding rules that the DNS Classifier needs to work.
        """
        #TODO
        self.logger.info("DNSMetadataEngine.get_forwarding_rules(): called")
        dnspkts = packets(None, ['srcmac'])
        self.offset = 42 #FIXME! THIS ONLY WORKS WITH IPv4
        dnspkts.register_callback(self._dns_parse_cb)

        dns_inbound = Match(dict(srcport = 53)) >> dnspkts
        dns_outbound = Match(dict(dstport = 53)) >> dnspkts

        return dns_inbound + dns_outbound

    #TODO
    def _dns_parse_cb(self, pkt):
        self.logger.info("DNSMetadataEngine._dns_parse_cb(): called")
        self.data_source.parse_new_DNS(pkt['raw'][self.offset:])
        #self.data_source.print_entries()

    def _install_new_rule(self, domain, ipaddr):
        self.data_source._install_new_rule(domain, ipaddr)
    

class DNSMetadataEntry(MetadataEntry):
    def __init__(self, data_source, engine, rule, add_rule_cb, remove_rule_cb):
        super(DNSMetadataEntry, self).__init__(data_source, engine, rule)
        
        self.register_callbacks(add_rule_cb, remove_rule_cb)
        self.data_source.set_new_callback(self.handle_new_entry_callback)
        if ACTIVE_MAPPING == True:
            self._active_timer = None
            self._active_results = []
            self._active_get_mapping()
                

    def handle_expiration_callback(self, addr, entry):
        self.logger.info("DNSMetadataEntry.handle_expiration_callback(): called with " + addr)
        #need to remove the rules that was generated by the particular DNSEntry
        #TODO
        self.remove_rule_cb(dict(ipv4_src=str(addr), eth_type=0x0800))
        self.remove_rule_cb(dict(ipv4_dst=str(addr), eth_type=0x0800))

    def handle_new_entry_callback(self, addr, entry):
        self.logger.info("DNSMetadataEntry.handle_new_entry_callback(): called with " + addr)
        for name in entry.names:
            if name == self.rule:
                self.add_rule_cb(dict(ipv4_src=addr), eth_type=0x0800)
                self.add_rule_cb(dict(ipv4_dst=addr), eth_type=0x0800)
                self.logger.debug("    New rule for " + name)
                entry.register_timeout_callback(self.handle_expiration_callback)

    def _active_get_mapping_expired(self):
        #self.logger.debug("_active_get_mapping_expired() called " + str(self._active_timer.is_alive()))
        self._active_timer.cancel()
        self._active_get_mapping()

    def _active_get_mapping(self):
        # Anly working on A record now
        if ((self._active_timer != None) and
            (self._active_timer.is_alive())):
                return
        try:
            results = resolver.query(self.rule, 'A')
            ttl = results.ttl

            self._active_timer = Timer(ttl, self._active_get_mapping_expired)
            self._active_timer.start()
            new_active_results = []
        
            # These two reduce churn: only adds things that weren't there from the 
            # previous pass, only deletes things that aren't there from this pass.
        
            # Add new addresses
            for addr in results:
                new_active_results.append(addr)
                if addr not in self._active_results:
                    print "adding addr: " + str(addr)
                    self.add_rule_cb(dict(ipv4_src=str(addr), eth_type=0x0800))
                    self.add_rule_cb(dict(ipv4_dst=str(addr), eth_type=0x0800))

            # Remove old addresses
            for addr in self._active_results:
                if addr not in results:
                    self.remove_rule_cb(dict(ipv4_src=str(addr), eth_type=0x0800))
                    self.remove_rule_cb(dict(ipv4_dst=str(addr), eth_type=0x0800))

            self._active_results = new_active_results
        except (resolver.NoAnswer, exception.Timeout, resolver.NXDOMAIN):
            self.logger.info("Could not query for " + self.rule + ". Trying again in 30 seconds.")
            self._active_timer = Timer(30, self._active_get_mapping_expired)
            self._active_timer.start()
            self._active_results = []
        

#--------------------------------------
# NetAssayMatch subclasses
#--------------------------------------

#TODO - is this necessary?
#class matchURL(NetAssayMatch):
class matchURL(object):
    """
    matches IPs related to the specified URL.
    """
    def __init__(self, url, matchaction):
        logging.getLogger('netassay.matchURL').info("matchURL.__init__(): called")
        metadata_engine = DNSMetadataEngine.get_instance()
        ruletype = AssayRule.DNS_NAME
        rulevalue = url
        super(matchURL, self).__init__(metadata_engine, ruletype, rulevalue, matchaction)

#class matchClass(NetAssayMatch):
class matchClass(object):
    """
    matches IPs related to the specified class of URLs.
    """
    def __init__(self, classification, matchaction):
        logging.getLogger('netassay.matchClass').info("matchURL.__init__(): called")
        metadata_engine = DNSMetadataEngine.get_instance()
        ruletype = AssayRule.CLASSIFICATION
        rulevalue = classification
        super(matchClass, self).__init__(metadata_engine, ruletype, rulevalue, matchaction)
